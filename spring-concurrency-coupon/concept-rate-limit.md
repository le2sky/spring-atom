#### 개념

- rate limiter는 클라이언트가 보내는 트래픽의 처리율을 제어한다.
- 가령, HTTP라면 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다.
- 제한 장치에 정의된 임계치를 넘어서면 추가 호출은 블락된다.
- 더욱 구체적인 예시
    - 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
- 서버, 클라이언트, 미들웨어에서 적용 가능

#### 장점

- DOS 공격에 의한 자원 고갈을 방지
- 서드파티 API 사용료 뻥튀기 예방
- 우선순위가 높은 API에 더 많은 자원 할당 가능
- 서버 과부화 예방

#### 처리율 제한 알고리즘

- 토큰 버킷 : 버킷 공급률과 버킷 크기, 버킷의 수를 고려해야한다.
- 누출 버킷 : 토큰 버킷과 비슷하지만, 요청 처리율이 고정, 버킷 크기와 처리율을 고려해야한다.
- 고정 윈도 카운터 : 윈도 경계 부근에 순간 트래픽 집중시, 윈도에 할당된 양보다 많은 요청 처리 가능
- 이동 윈도 로그 : 고정 윈도의 단점을 개선하지만, 다량의 메모리를 사용(거부된 타임 스탬프 로그도 보관)
- 이동 윈도 카운터 : 고정 윈도와 이동 윈도 로그의 결합 방식

#### 핵심

- 핵심은 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고
    - 추적 대상은 사용자 별인가? 아니면 IP 주소별로? 아니면 엔드포인트? 서비스 단위?
- 카운터의 값이 한도를 넘어서면 넘어 도착한 요청은 거부하는 것이다.

#### 카운터는 어디에 보관하는가?

- DB -> 디스크 접근 때문에 느리다.
- Redis -> 가장 많이 사용된다. (하늘) 미들 웨어 관리 비용이 단점일듯

#### 초과된 요청을 처리하는 여러가지 방법

- 요청을 그대로 버리거나
- 메시지 큐에 보관하여 나중에 처리할 수도 있다.

#### 처리율 제한 장치가 사용하는 HTTP 응답 헤더

- X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청 수
- X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청 수
- X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 다시 요청을 보내야 하는지 알림
