### 동시성 문제를 처리율 제한으로 해결하려는 접근 방식

#### 가설

처리율 제한 장치의 장점은 근본적으로 다음과 같다.

- DOS 공격에 의한 자원 고갈과 서버 과부하(사용자의 잘못된 사용 패턴, 봇 트래픽)를 방지한다.
- 서드파티 API 사용료 뻥튀기를 예방한다.

그렇다면 위와 같은 장점을 취하면서 동시성 문제를 해결하면 일석이조이지 않을까라는 생각을 했다.
아이디어는 다음과 같다.

- 기본적으로 동시성 문제는 서버의 동시 처리 능력과 연관이 있다.
- 극단적으로 생각했을 때, 서버의 스레드를 한 개로 제한하면 동시성 문제는 절대 발생하지 않는다.
- (가설) 특정 API의 동시 처리 능력을 희생시키면 동시성 문제가 발생하지 않고, 처리율 제한의 이점도 얻어갈 수 있을 것이다.

#### 적용

- 쿠폰 발급 API에 처리율 제한을 설정한다. (Guava 라이브러리의 처리율 제한 기능을 사용)
- Guava를 이용하였기 때문에, 처리율 제한은 각 was에서 처리한다.
- 100개 스레드에 같은 사용자와 같은 쿠폰의 ID로 동시에 쿠폰 발급 API에 요청한다.
- 처리율 제한에 막히는 경우 429 (Too Many Request) 응답을 내려주고 요청을 무시한다.
- 사용자는 쿠폰을 단 한번만 발급할 수 있다.

#### 장점과 한계

장점 :

- 이미 시스템에 처리율 제한 장치가 있다면 적용이 유리할 수 있다.
    - 예를 들어, 한 시스템에서 처리율 제한 장치가 이미 존재한다고 가정하자.
    - 1초에 한 IP를 가진 사용자는 쿠폰 발급 API를 1번만 요청하도록 처리율을 제한할 수 있다.
- 커넥션을 사용하지 않는다.
    - 처리율 제한에 막히는 경우 spring trasaction aop 프록시를 호출하지 않으니 커넥션을 점유하지 않고 동시성 문제를 해결한다.
    - 하지만, 이는 처리율 제한 장치만의 이점은 아니다. 자바 동기화 방식으로도 커넥션을 점유하지 않을 수 있을 것이다

한계 :

- 분산 환경에서 동시성 문제가 발생한다.
    - 가령, 동시 요청 [1, 2]가 있을 때, 1은 a was, 2는 b was로 가는 경우 무용이다.
    - 이런 경우, 처리율 제한 장치가 레디스와 같은 카운터 저장소를 사용하도록 할 수 있지만, 유지보수대상이 증가한다.
    - 이 경우 차라리 분산락을 도입하는 것이 합리적이다.
- 단순 동시성 문제를 해결하기 위해서 도입하기에는 애매한 지점이 있다.
    - 처리율 제한 장치 설계에 대한 고려가 필요하다.
    - 동시성 문제 해결을 위한 처리율 제한 수치와 근본적으로 사용해야하는 처리율 제한의 수치가 다를 수 있다.
