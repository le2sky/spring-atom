### 동시성 문제를 자바에서 제공하는 동기화 도구로 해결하려는 접근 방식

#### 가설

- (가설) 자바에서 제공하는 동기화 도구를 사용해서 동시성 문제를 해결하면 데이터베이스 커넥션을 점유하지 않으면서, 문제를 해결할 수 있지 않을까?

#### 적용

- 암묵적인 락을 사용하거나, 명시적인 락을 사용할 수 있다.
- 명시적인 락
    - memberId와 couponId를 Map의 키로 관리한다.
    - Map의 값은 ReentrantLock을 사용한다.
    - Map은 ConcurrentHashMap을 사용한다.
    - MemberCouponIssueLock 인터페이스를 구현하는 JavaMemberCouponIssueLock에서 Map을 관리한다.
    - MemberCouponIssueLock은 응용 계층에 존재하여 다른 개발자가 제어할 수 있고, 구현체를 변경할 수 있다.
    - finally 구문에서 lock을 릴리즈해줘야 한다.

- 암묵적인 락
    - synchronized 키워드를 이용한다.

#### 적용 시 주의사항

- 데이터베이스 트랜잭션의 시점을 주의해야 한다.
- 데이터베이스 트랜잭션이 커밋하기 이전에 락을 릴리즈하면 동시성 문제가 다시 발생한다.
    - 이를 위해서 상위 계층 코드(파사드 같은)에서 락을 릴리즈하거나, synchronized를 설정해야 한다.
- 만약 부모 트랜잭션에 합류하고 있는 경우에는 부모 트랜잭션이 종료되는 경우 커밋이 된다. 즉, 커밋을 수행하기 이전에 락을 릴리즈하여 동시성 문제가 발생한다.
    - 이 경우에는 트랜잭션 전파 옵션(ex. REQUIRES_NEW)으로 해결할 수 있다. 하지만, 스레드가 두 개 이상의 커넥션을 동시에 점유하려는 경우, 부하 환경에서 히카리 커넥션 풀 데드락이 발생할 수
      있다.
- 명시적인 락의 경우에는 락을 릴리즈해야한다. 릴리즈하지 않으면 다른 스레드가 대기 상태로 머무르고, 예기치 못한 동작이 발생할 수 있다.

#### 장점과 한계

- lock을 사용하는 경우, 애플리케이션 레이어에서 동시성을 제어할 수 있기 때문에 확장성있는 코드를 작성할 수 있다.
    - 가령, MemberCouponIssueLock 인터페이스의 구현체를 분산락이나 다른 것으로 대체 가능하다.
- synchronized를 사용하는 경우, 락 릴리즈에 대한 걱정을 덜어낼 수 있다.
- 두 방식 모두 트랜잭션 없는 상위 계층에서 락 획득 시도를 하면 데이터베이스 커넥션을 점유하지 않고 스레드가 대기한다.
- (한계) 두 방식은 서버가 다중화되어있는 환경에서 다시 동시성 문제가 발생할 수 있다.
    - (가설) 스티키 세션을 이용하면 한 사용자에 대한 동시 호출 문제는 예방할 수 있을 것이다.
