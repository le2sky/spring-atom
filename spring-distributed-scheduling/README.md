메일을 분산환경에서 스케줄링하여 보내야하는데, 어떻게 풀어볼 수 있을까?
스프링을 사용하는 분산환경에서 안전하게 스케줄링 로직을 수행하는 방법은 무엇이 있을까?

- mysql named lock이나 was 환경 변수에 was 번호와 전체 was 수를 입력하는 방법을 생각해봤다.
- 찾아보니, shedLock, 분산 스케줄링이라는 개념이 있는데.. 알아보자.

```
java -jar ./build/libs/subscribe-mail-send-0.0.1-SNAPSHOT.jar
```

#### 문제 상황

- 1대 서버에서 `@Scheduled`를 이용해 전체 구독자를 순회하면서 메일을 발송
- 서버가 2대가 된다면 각 사용자는 중복 메일을 받게되는 문제가 발생

#### 1대의 서버에서만 스케줄링을 수행 with ShedLock

- ShedLock이라는 라이브러리를 사용하면 이를 달성 가능
- 하지만, ShedLock을 사용하는 경우에는 오전 7시에 메일을 발송하기 위한 부하를 1대의 서버에서만 감당해야하기 때문에 효율적이지 않다고 판단

#### 모듈러 연산을 사용한 방식

- 데이터베이스를 샤딩했을 때, 샤딩 키를 활용하는 것에서 아이디어를 차용
- `server index = subscrbe id % server count`를 기반으로 각 서버에서 구독자에게 메일을 발송할지 결정하는 원리
- 가장 단순하게 해결할 수 있는 것이 장점
- (단점) 다만, subscribe id는 완전히 순차적이지 않고 id가 비어있는 부분이 있기 때문에 완전히 부하를 균등하게 나눠 가질 수 없음.
- (단점) 그리고, server index와 server count를 환경 변수로 관리해야하는 대가를 치뤄야함

#### MySQL 분산 잠금을 사용하는 방식

- MySQL 분산 잠금을 사용한 이유는 분산 환경에서도 안정적으로 동작할 수 있는 방법이고 매일메일에서 MySQL을 이미 사용하고 있기 때문

#### 분산 잠금 활용(version 0)

- 2대의 서버가 동시에 전체 구독자(subscribe)를 순회한다.
- 각 서버는 subscribe id를 분산 잠금의 키로 활용하여 획득을 시도한다.
- 잠금 획득에 성공하면 메일을 발송한다.
- 잠금 획득에 실패하면 메일을 발송하지 않는다.
- 메일 발송에 성공하면 잠금을 획득한 커넥션을 이용해 잠금을 해제한다.

각 서버의 순회 시간이 균형적이지 않으면 다시 중복 메일을 발생할 위험이 있음

- 가령, 1번 서버에서 1004번 구독자를 잠금하고 메일을 발송하고 잠금을 해제했을 때, 2번 서버에서 1004번 구독자에 대해 다시 잠금을 획득하여 중복 메일을 전송할 수 있음. (순회 시간의 불균형으로 인한
  중복 메일 발송)
- 이를 해결하기 위해서는 분산 잠금을 모든 메일이 다 발송된 경우에만 해제하도록 구현해야함. (version 1)

#### 분산 잠금 활용(version 1)

- 2대의 서버가 동시에 전체 구독자(subscribe)를 순회한다.
- 각 서버는 subscribe id를 분산 잠금의 키로 활용하여 획득을 시도한다.
- 잠금 획득에 성공하면 메일을 발송한다.
- 잠금 획득에 실패하면 메일을 발송하지 않는다.
- 모든 서버가 메일을 전부 발송했다고 판단되는 시간에 모든 잠금을 해제하는 스케줄을 등록한다.

잠금 해제에 스케줄을 이용하는 근거는 전체 메일을 순회한 이후에 잠금을 해제하면 다시 순회 시간 불균형으로 인해 중복 메일이 발생할 수 있기 때문이다. 그리고, 다음과 같은 환경에서 version 1번을 검증하였고
거의 균등하게 전송을 시도함

- 4개의 스프링 프로세스를 실행하고 100개의 구독자를 생성
- 실제 메일이 발송되면 안되니 메일 전송 로직을 주석 처리하고 Thread.sleep(100)을 추가
- cpu 코어 10개인 환경에서 수행

구독자가 100명이고 2대의 서버가 50개씩 메일을 전송하기 위해서 각각 100번의 잠금 획득 시도를 위한 데이터베이스 요청을 보내게 됨.

- (비효율 개선) 이를 해결하기 위해서 배치 사이즈라는 개념을 고안 (version2)

#### 분산 잠금 활용(version 2)

- 전체 구독자 수를 batchSize 수로 나누어 loopCount를 구한다.
- loopCount만큼 순회하면서 batchSize 만큼 잠금을 시도한다. 키 예시) schedule-10, schedule-20
- 잠금 획득에 성공하면 batchSize만큼 메일을 발송한다.
- 잠금 획득에 실패하면 메일을 발송하지 않는다.
- 모든 서버가 메일을 전부 발송했다고 판단되는 시간에 모든 잠금을 해제하는 스케줄을 등록한다.

MySQL 분산 잠금을 활용한 방식은 모듈러 연산처럼 환경변수를 관리하지 않아도 되고, 균등하고 중복없이 메일을 발송할 수 있음

- (단점) 잠금을 해제하기 위한 커넥션을 별도로 어딘가에 보관해야하고, 다른 방식에 비해 데이터베이스 요청 수가 더 많고, 코드의 복잡도가 높음
